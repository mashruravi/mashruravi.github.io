{"componentChunkName":"component---src-components-blog-layout-js","path":"/blog/2020-02-23-angular-javascript/","webpackCompilationHash":"889bca696b2d2183ba14","result":{"data":{"mdx":{"id":"5336b265-a21d-54cd-8734-7f6bc80035cd","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Calling Angular Component Functions from JavaScript\",\n  \"date\": \"2020-02-23T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I recently had to work on an Angular application that used the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://getbootstrap.com/docs/4.3/components/popovers/\"\n  }), \"Bootstrap library to show a popover\"), \". The popover content needed to have a link that would open up a dialog (using the Dialog component from Angular\\u2019s Material library) when clicked.\"), mdx(\"p\", null, \"Putting the weird requirement aside for a moment, this kind of interaction posed a unique technical challenge. There were two things that needed to be done:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There would be a button on the UI. Clicking this button would open a popover with a link.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Clicking on the link in the popover would open a dialog.\")), mdx(\"p\", null, \"The first part is very straight forward. Create a button and initialise the popover on it. This can be done in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ngAfterViewInit\"), \" lifecycle hook:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"public ngAfterViewInit(): void {\\n  $('[data-toggle=\\\"popover\\\"]').popover();\\n}\\n\")), mdx(\"p\", null, \"The content of the popover has to be in HTML:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"<button type=\\\"button\\\"\\n        class=\\\"btn btn-primary\\\"\\n        data-container=\\\"body\\\"\\n        data-toggle=\\\"popover\\\"\\n        data-placement=\\\"bottom\\\"\\n        data-html=true\\n        data-content=\\\"<p>Click<a href='#' (click)='openDialog()'>here</a>...</p>\\\">\\n\\n  Click to open\\n\\n</button>\\n\")), mdx(\"p\", null, \"This doesn't work because the click handler that we attached was interpreted as a string and it doesn\\u2019t actually trigger anything on click. This is because we can only call \\u201Cnormal\\u201D JavaScript functions from the popover. For example, the following alert would work:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"data-content =\\n  `<p>This is a <a href='#' onclick=\\\"alert('Thanks for clicking...')\\\">link</a> you need to click</p>`\\n\")), mdx(\"p\", null, \"Similarly, we can call a function that would handle the click event. This click handler needs to be accessible to the popover content in the global execution context.\"), mdx(\"p\", null, \"To do this, we first make the following changes in the component:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Create a namespace for the functions we will create\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"declare global {\\n  interface Window { MyCustomNamespace: any; }\\n}\\n\\nwindow.MyCustomNamespace = window.MyCustomNamespace || {};\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Inject NgZone\")), mdx(\"p\", null, \"The function that will be run from the global execution context will be running outside Angular's zone. We need to hook back into the zone in the code we write.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"import { NgZone } from '@angular/core';\\n\\n...\\n\\nconstructor( private zone: NgZone ){}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Use a function in the created namespace as a click handler\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"<button type=\\\"button\\\"\\n        class=\\\"btn btn-primary\\\"\\n        data-container=\\\"body\\\"\\n        data-toggle=\\\"popover\\\"\\n        data-placement=\\\"bottom\\\"\\n        data-html=true\\n        data-content=\\\"<p>Click <a href='#' onclick='MyCustomNamespace.openDialog()'>here</a>...</p>\\\">\\n\\n  Click to open\\n\\n</button>\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Define the function used as a click handler\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"window.ExternalPlannedNamespace.openDialog = () => {\\n  // Since this function runs outside Angular's zone, we need to get back inside!\\n  this.zone.run(() => {\\n    // Put angular code that has to be called on click on the link in the popover here...\\n  });\\n}\\n\")), mdx(\"p\", null, \"Of course this entire problem could have been avoided by not dropping the popover library into an Angular application in the first place. Using a wrapper like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/ngx-bootstrap\"\n  }), \"ngx-bootstrap\"), \" would have been a better option.\"), mdx(\"p\", null, \"However, this is an interesting hack to have in your toolbox if you ever want to hook back into an Angular context from \\u201Cregular\\u201D JavaScript (especially when working with legacy codebases).\"), mdx(\"hr\", null), mdx(\"p\", null, \"Reference: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/questions/12709074/how-do-you-explicitly-set-a-new-property-on-window-in-typescript\"\n  }), \"StackOverflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Calling Angular Component Functions from JavaScript"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"5336b265-a21d-54cd-8734-7f6bc80035cd"}}}